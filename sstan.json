{"comment":"Sstan","footnote":"","findings":[{"severity":"High","title":"Uninitialized storage variables","description":"A storage variable that is declared but not initialized will have a default value of zero (or the equivalent, such as an empty array for array types or zero-address for address types). Failing to initialize a storage variable can pose risks if the contract logic assumes that the variable has been explicitly set to a particular value.","gasSavings":null,"category":null,"instances":[{"content":["595:    uint256 decimals = 6;\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Low","title":"Use a locked pragma version instead of a floating pragma version","description":"\"\"\n        Floating pragma is a vulnerability in smart contract code that can cause unexpected behavior by allowing the compiler to use a specified range of versions. \\n This can lead to issues such as using an older compiler version with known vulnerabilities, using a newer compiler version with undiscovered vulnerabilities, inconsistency across files using different versions, or unpredictable behavior because the compiler can use any version within the specified range. It is recommended to use a locked pragma version in order to avoid these potential vulnerabilities. In some cases it may be acceptable to use a floating pragma, such as when a contract is intended for consumption by other developers and needs to be compatible with a range of compiler versions.\n        <details>\n        <summary>Expand Example</summary>\n\n        #### Bad\n\n        ```js\n            pragma solidity ^0.8.0;\n        ```\n\n        #### Good\n\n        ```js\n            pragma solidity 0.8.15;\n        ```\n        </details>\n        \"\"","gasSavings":null,"category":null,"instances":[{"content":["5:pragma solidity ^0.8.0;\n"],"loc":["./src/Contract.sol"]},{"content":["86:pragma solidity ^0.8.0;\n"],"loc":["./src/Contract.sol"]},{"content":["116:pragma solidity ^0.8.0;\n"],"loc":["./src/Contract.sol"]},{"content":["143:pragma solidity ^0.8.0;\n"],"loc":["./src/Contract.sol"]},{"content":["510:pragma solidity ^0.8.0;\n"],"loc":["./src/Contract.sol"]},{"content":["588:pragma solidity ^0.8.24;\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Low","title":"Unsafe ERC20 Operation","description":"\"\"\n        ERC20 operations can be unsafe due to different implementations and vulnerabilities in the standard. To account for this, either use OpenZeppelin's SafeERC20 library or wrap each operation in a require statement. \\n\n        > Additionally, ERC20's approve functions have a known race-condition vulnerability. To account for this, use OpenZeppelin's SafeERC20 library's `safeIncrease` or `safeDecrease` Allowance functions.\n        <details>\n        <summary>Expand Example</summary>\n\n        #### Unsafe Transfer\n\n        ```js\n        IERC20(token).transfer(msg.sender, amount);\n        ```\n\n        #### OpenZeppelin SafeTransfer\n\n        ```js\n        import {SafeERC20} from \\\"openzeppelin/token/utils/SafeERC20.sol\\\";\n        //--snip--\n\n        IERC20(token).safeTransfer(msg.sender, address(this), amount);\n        ```\n                \n        #### Safe Transfer with require statement.\n\n        ```js\n        bool success = IERC20(token).transfer(msg.sender, amount);\n        require(success, \\\"ERC20 transfer failed\\\");\n        ```\n                \n        #### Unsafe TransferFrom\n\n        ```js\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        ```\n\n        #### OpenZeppelin SafeTransferFrom\n\n        ```js\n        import {SafeERC20} from \\\"openzeppelin/token/utils/SafeERC20.sol\\\";\n        //--snip--\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        ```\n                \n        #### Safe TransferFrom with require statement.\n\n        ```js\n        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);\n        require(success, \\\"ERC20 transfer failed\\\");\n        ```\n\n        </details>\n        \"\"","gasSavings":null,"category":null,"instances":[{"content":["684:        require(usdcAddress.transfer(adminWallet, usdcAddress.balanceOf(address(this))));\n"],"loc":["./src/Contract.sol"]},{"content":["707:        require(usdcAddress.transferFrom(msg.sender, adminWallet, amount));\n"],"loc":["./src/Contract.sol"]},{"content":["782:        bool sent = usdcAddress.transferFrom(adminWallet, address(this), totalWithdrawAmount);\n"],"loc":["./src/Contract.sol"]},{"content":["826:        require(usdcAddress.transfer(msg.sender, amountToSend));\n"],"loc":["./src/Contract.sol"]},{"content":["840:        bool sent = usdcAddress.transferFrom(adminWallet, address(this), amount);\n"],"loc":["./src/Contract.sol"]},{"content":["853:        require(usdcAddress.transfer(msg.sender, userReward));\n"],"loc":["./src/Contract.sol"]},{"content":["873:        require(usdcAddress.transfer(adminWallet, userReward));\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Constructor should be listed before any other function","description":"Consider changing the order of the functions so that the constructor is listed first","gasSavings":null,"category":null,"instances":[{"content":["192:    constructor(string memory name_, string memory symbol_) {\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Constructor should check that all parameters are not 0","description":"Consider adding a require statement to check that all parameters are not 0 in the constructor","gasSavings":null,"category":null,"instances":[{"content":["192:    constructor(string memory name_, string memory symbol_) {\n"],"loc":["./src/Contract.sol"]},{"content":["192:    constructor(string memory name_, string memory symbol_) {\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Contract names should be in PascalCase","description":"Ensure that contract definitions are declared using PascalCase","gasSavings":null,"category":null,"instances":[{"content":[""],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Large contracts with many external functions should inherit an interface","description":"Consider inheriting the interface to ensure the interface matches the contract spec","gasSavings":null,"category":null,"instances":[{"content":["592:contract numericalVault1 is ReentrancyGuard{\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Storage variables should not have implicit visibility","description":"Consider explicitly specifying the visibility of storage variables for readability","gasSavings":null,"category":null,"instances":[{"content":["594:    ERC20 usdcAddress = ERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);\n"],"loc":["./src/Contract.sol"]},{"content":["595:    uint256 decimals = 6;\n"],"loc":["./src/Contract.sol"]},{"content":["612:    rewardHistory[] history;\n"],"loc":["./src/Contract.sol"]},{"content":["614:    address[] sucessfullyDeposited;\n"],"loc":["./src/Contract.sol"]},{"content":["615:    address[] awaitingApproval;\n"],"loc":["./src/Contract.sol"]},{"content":["616:    address[] withdrawRequests;\n"],"loc":["./src/Contract.sol"]},{"content":["632:    mapping (address => depositor) userDepositInfo;\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Function names should be in camelCase","description":"Ensure that function definitions are declared using camelCase","gasSavings":null,"category":null,"instances":[{"content":["42:    function transfer(address to, uint256 amount) external returns (bool);\n"],"loc":["./src/Contract.sol"]},{"content":["51:    function allowance(address owner, address spender) external view returns (uint256);\n"],"loc":["./src/Contract.sol"]},{"content":["67:    function approve(address spender, uint256 amount) external returns (bool);\n"],"loc":["./src/Contract.sol"]},{"content":["98:    function name() external view returns (string memory);\n"],"loc":["./src/Contract.sol"]},{"content":["103:    function symbol() external view returns (string memory);\n"],"loc":["./src/Contract.sol"]},{"content":["108:    function decimals() external view returns (uint8);\n"],"loc":["./src/Contract.sol"]},{"content":["200:    function name() public view virtual override returns (string memory) {\n"],"loc":["./src/Contract.sol"]},{"content":["208:    function symbol() public view virtual override returns (string memory) {\n"],"loc":["./src/Contract.sol"]},{"content":["225:    function decimals() public view virtual override returns (uint8) {\n"],"loc":["./src/Contract.sol"]},{"content":["251:    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["260:    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n"],"loc":["./src/Contract.sol"]},{"content":["274:    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["360:    function _transfer(address from, address to, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["389:    function _mint(address account, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["415:    function _burn(address account, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["446:    function _approve(address owner, address spender, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["687:    function deposit(uint256 amount) external nonReentrant{\n"],"loc":["./src/Contract.sol"]},{"content":["815:    function withdraw() external nonReentrant{\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Require/Revert statements should be consistent across the codebase","description":"Consider using require/revert statements consistently across the codebase","gasSavings":null,"category":null,"instances":[{"content":["540:    uint256 private constant _NOT_ENTERED = 1;\n"],"loc":["./src/Contract.sol"]},{"content":["541:    uint256 private constant _ENTERED = 2;\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Only define one contract per file","description":"It is best practice to only define one contract per file.","gasSavings":null,"category":null,"instances":[{"content":["176:contract ERC20 is Context, IERC20, IERC20Metadata {\n177:    mapping(address => uint256) private _balances;\n178:\n179:    mapping(address => mapping(address => uint256)) private _allowances;\n180:\n181:    uint256 private _totalSupply;\n182:\n183:    string private _name;\n184:    string private _symbol;\n185:\n186:    /**\n187:     * @dev Sets the values for {name} and {symbol}.\n188:     *\n189:     * All two of these values are immutable: they can only be set once during\n190:     * construction.\n191:     */\n192:    constructor(string memory name_, string memory symbol_) {\n193:        _name = name_;\n194:        _symbol = symbol_;\n195:    }\n196:\n197:    /**\n198:     * @dev Returns the name of the token.\n199:     */\n200:    function name() public view virtual override returns (string memory) {\n201:        return _name;\n202:    }\n203:\n204:    /**\n205:     * @dev Returns the symbol of the token, usually a shorter version of the\n206:     * name.\n207:     */\n208:    function symbol() public view virtual override returns (string memory) {\n209:        return _symbol;\n210:    }\n211:\n212:    /**\n213:     * @dev Returns the number of decimals used to get its user representation.\n214:     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n215:     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n216:     *\n217:     * Tokens usually opt for a value of 18, imitating the relationship between\n218:     * Ether and Wei. This is the default value returned by this function, unless\n219:     * it's overridden.\n220:     *\n221:     * NOTE: This information is only used for _display_ purposes: it in\n222:     * no way affects any of the arithmetic of the contract, including\n223:     * {IERC20-balanceOf} and {IERC20-transfer}.\n224:     */\n225:    function decimals() public view virtual override returns (uint8) {\n226:        return 18;\n227:    }\n228:\n229:    /**\n230:     * @dev See {IERC20-totalSupply}.\n231:     */\n232:    function totalSupply() public view virtual override returns (uint256) {\n233:        return _totalSupply;\n234:    }\n235:\n236:    /**\n237:     * @dev See {IERC20-balanceOf}.\n238:     */\n239:    function balanceOf(address account) public view virtual override returns (uint256) {\n240:        return _balances[account];\n241:    }\n242:\n243:    /**\n244:     * @dev See {IERC20-transfer}.\n245:     *\n246:     * Requirements:\n247:     *\n248:     * - `to` cannot be the zero address.\n249:     * - the caller must have a balance of at least `amount`.\n250:     */\n251:    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n252:        address owner = _msgSender();\n253:        _transfer(owner, to, amount);\n254:        return true;\n255:    }\n256:\n257:    /**\n258:     * @dev See {IERC20-allowance}.\n259:     */\n260:    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n261:        return _allowances[owner][spender];\n262:    }\n263:\n264:    /**\n265:     * @dev See {IERC20-approve}.\n266:     *\n267:     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n268:     * `transferFrom`. This is semantically equivalent to an infinite approval.\n269:     *\n270:     * Requirements:\n271:     *\n272:     * - `spender` cannot be the zero address.\n273:     */\n274:    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n275:        address owner = _msgSender();\n276:        _approve(owner, spender, amount);\n277:        return true;\n278:    }\n279:\n280:    /**\n281:     * @dev See {IERC20-transferFrom}.\n282:     *\n283:     * Emits an {Approval} event indicating the updated allowance. This is not\n284:     * required by the EIP. See the note at the beginning of {ERC20}.\n285:     *\n286:     * NOTE: Does not update the allowance if the current allowance\n287:     * is the maximum `uint256`.\n288:     *\n289:     * Requirements:\n290:     *\n291:     * - `from` and `to` cannot be the zero address.\n292:     * - `from` must have a balance of at least `amount`.\n293:     * - the caller must have allowance for ``from``'s tokens of at least\n294:     * `amount`.\n295:     */\n296:    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n297:        address spender = _msgSender();\n298:        _spendAllowance(from, spender, amount);\n299:        _transfer(from, to, amount);\n300:        return true;\n301:    }\n302:\n303:    /**\n304:     * @dev Atomically increases the allowance granted to `spender` by the caller.\n305:     *\n306:     * This is an alternative to {approve} that can be used as a mitigation for\n307:     * problems described in {IERC20-approve}.\n308:     *\n309:     * Emits an {Approval} event indicating the updated allowance.\n310:     *\n311:     * Requirements:\n312:     *\n313:     * - `spender` cannot be the zero address.\n314:     */\n315:    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n316:        address owner = _msgSender();\n317:        _approve(owner, spender, allowance(owner, spender) + addedValue);\n318:        return true;\n319:    }\n320:\n321:    /**\n322:     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n323:     *\n324:     * This is an alternative to {approve} that can be used as a mitigation for\n325:     * problems described in {IERC20-approve}.\n326:     *\n327:     * Emits an {Approval} event indicating the updated allowance.\n328:     *\n329:     * Requirements:\n330:     *\n331:     * - `spender` cannot be the zero address.\n332:     * - `spender` must have allowance for the caller of at least\n333:     * `subtractedValue`.\n334:     */\n335:    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n336:        address owner = _msgSender();\n337:        uint256 currentAllowance = allowance(owner, spender);\n338:        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n339:        unchecked {\n340:            _approve(owner, spender, currentAllowance - subtractedValue);\n341:        }\n342:\n343:        return true;\n344:    }\n345:\n346:    /**\n347:     * @dev Moves `amount` of tokens from `from` to `to`.\n348:     *\n349:     * This internal function is equivalent to {transfer}, and can be used to\n350:     * e.g. implement automatic token fees, slashing mechanisms, etc.\n351:     *\n352:     * Emits a {Transfer} event.\n353:     *\n354:     * Requirements:\n355:     *\n356:     * - `from` cannot be the zero address.\n357:     * - `to` cannot be the zero address.\n358:     * - `from` must have a balance of at least `amount`.\n359:     */\n360:    function _transfer(address from, address to, uint256 amount) internal virtual {\n361:        require(from != address(0), \"ERC20: transfer from the zero address\");\n362:        require(to != address(0), \"ERC20: transfer to the zero address\");\n363:\n364:        _beforeTokenTransfer(from, to, amount);\n365:\n366:        uint256 fromBalance = _balances[from];\n367:        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n368:        unchecked {\n369:            _balances[from] = fromBalance - amount;\n370:            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n371:            // decrementing then incrementing.\n372:            _balances[to] += amount;\n373:        }\n374:\n375:        emit Transfer(from, to, amount);\n376:\n377:        _afterTokenTransfer(from, to, amount);\n378:    }\n379:\n380:    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n381:     * the total supply.\n382:     *\n383:     * Emits a {Transfer} event with `from` set to the zero address.\n384:     *\n385:     * Requirements:\n386:     *\n387:     * - `account` cannot be the zero address.\n388:     */\n389:    function _mint(address account, uint256 amount) internal virtual {\n390:        require(account != address(0), \"ERC20: mint to the zero address\");\n391:\n392:        _beforeTokenTransfer(address(0), account, amount);\n393:\n394:        _totalSupply += amount;\n395:        unchecked {\n396:            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n397:            _balances[account] += amount;\n398:        }\n399:        emit Transfer(address(0), account, amount);\n400:\n401:        _afterTokenTransfer(address(0), account, amount);\n402:    }\n403:\n404:    /**\n405:     * @dev Destroys `amount` tokens from `account`, reducing the\n406:     * total supply.\n407:     *\n408:     * Emits a {Transfer} event with `to` set to the zero address.\n409:     *\n410:     * Requirements:\n411:     *\n412:     * - `account` cannot be the zero address.\n413:     * - `account` must have at least `amount` tokens.\n414:     */\n415:    function _burn(address account, uint256 amount) internal virtual {\n416:        require(account != address(0), \"ERC20: burn from the zero address\");\n417:\n418:        _beforeTokenTransfer(account, address(0), amount);\n419:\n420:        uint256 accountBalance = _balances[account];\n421:        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n422:        unchecked {\n423:            _balances[account] = accountBalance - amount;\n424:            // Overflow not possible: amount <= accountBalance <= totalSupply.\n425:            _totalSupply -= amount;\n426:        }\n427:\n428:        emit Transfer(account, address(0), amount);\n429:\n430:        _afterTokenTransfer(account, address(0), amount);\n431:    }\n432:\n433:    /**\n434:     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n435:     *\n436:     * This internal function is equivalent to `approve`, and can be used to\n437:     * e.g. set automatic allowances for certain subsystems, etc.\n438:     *\n439:     * Emits an {Approval} event.\n440:     *\n441:     * Requirements:\n442:     *\n443:     * - `owner` cannot be the zero address.\n444:     * - `spender` cannot be the zero address.\n445:     */\n446:    function _approve(address owner, address spender, uint256 amount) internal virtual {\n447:        require(owner != address(0), \"ERC20: approve from the zero address\");\n448:        require(spender != address(0), \"ERC20: approve to the zero address\");\n449:\n450:        _allowances[owner][spender] = amount;\n451:        emit Approval(owner, spender, amount);\n452:    }\n453:\n454:    /**\n455:     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n456:     *\n457:     * Does not update the allowance amount in case of infinite allowance.\n458:     * Revert if not enough allowance is available.\n459:     *\n460:     * Might emit an {Approval} event.\n461:     */\n462:    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n463:        uint256 currentAllowance = allowance(owner, spender);\n464:        if (currentAllowance != type(uint256).max) {\n465:            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n466:            unchecked {\n467:                _approve(owner, spender, currentAllowance - amount);\n468:            }\n469:        }\n470:    }\n471:\n472:    /**\n473:     * @dev Hook that is called before any transfer of tokens. This includes\n474:     * minting and burning.\n475:     *\n476:     * Calling conditions:\n477:     *\n478:     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n479:     * will be transferred to `to`.\n480:     * - when `from` is zero, `amount` tokens will be minted for `to`.\n481:     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n482:     * - `from` and `to` are never both zero.\n483:     *\n484:     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n485:     */\n486:    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n487:\n488:    /**\n489:     * @dev Hook that is called after any transfer of tokens. This includes\n490:     * minting and burning.\n491:     *\n492:     * Calling conditions:\n493:     *\n494:     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n495:     * has been transferred to `to`.\n496:     * - when `from` is zero, `amount` tokens have been minted for `to`.\n497:     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n498:     * - `from` and `to` are never both zero.\n499:     *\n500:     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n501:     */\n502:    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n503:}\n"],"loc":["./src/Contract.sol"]},{"content":[""],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Constant and immutable variable names should be in SCREAMING_SNAKE_CASE","description":"Ensure that Constant and immutable variable names are declared using SCREAMING_SNAKE_CASE","gasSavings":null,"category":null,"instances":[{"content":["540:    uint256 private constant _NOT_ENTERED = 1;\n"],"loc":["./src/Contract.sol"]},{"content":["541:    uint256 private constant _ENTERED = 2;\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Consider marking public function External","description":"If a public function is never called internally, it is best practice to mark it as external.","gasSavings":null,"category":null,"instances":[{"content":["335:    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["251:    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["296:    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["315:    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["200:    function name() public view virtual override returns (string memory) {\n"],"loc":["./src/Contract.sol"]},{"content":["232:    function totalSupply() public view virtual override returns (uint256) {\n"],"loc":["./src/Contract.sol"]},{"content":["208:    function symbol() public view virtual override returns (string memory) {\n"],"loc":["./src/Contract.sol"]},{"content":["225:    function decimals() public view virtual override returns (uint8) {\n"],"loc":["./src/Contract.sol"]},{"content":["239:    function balanceOf(address account) public view virtual override returns (uint256) {\n"],"loc":["./src/Contract.sol"]},{"content":["274:    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Consider adding a message with require and revert statements","description":"Adding a message to accompany require statements will provide more context when a transaction fails.","gasSavings":null,"category":null,"instances":[{"content":["644:        require(msg.sender == owner);\n"],"loc":["./src/Contract.sol"]},{"content":["684:        require(usdcAddress.transfer(adminWallet, usdcAddress.balanceOf(address(this))));\n"],"loc":["./src/Contract.sol"]},{"content":["706:        require(usdcAddress.balanceOf(msg.sender) >= amount);\n"],"loc":["./src/Contract.sol"]},{"content":["707:        require(usdcAddress.transferFrom(msg.sender, adminWallet, amount));\n"],"loc":["./src/Contract.sol"]},{"content":["790:        require(userInfo.amount > 0 || userInfo.pendingAmount > 0);\n"],"loc":["./src/Contract.sol"]},{"content":["793:        require(userInfo.amount + userInfo.pendingAmount >= userInfo.withrawalRequestAmount + amount);\n"],"loc":["./src/Contract.sol"]},{"content":["806:        require(findAddressIndex(withdrawRequests, msg.sender) <= withdrawRequests.length);\n"],"loc":["./src/Contract.sol"]},{"content":["818:        require(userInfo.withdrawApproved);\n"],"loc":["./src/Contract.sol"]},{"content":["825:        require(usdcAddress.balanceOf(address(this)) >= amountToSend);\n"],"loc":["./src/Contract.sol"]},{"content":["826:        require(usdcAddress.transfer(msg.sender, amountToSend));\n"],"loc":["./src/Contract.sol"]},{"content":["847:        require(userInfo.claimableRewards > 0);\n"],"loc":["./src/Contract.sol"]},{"content":["852:        require(usdcAddress.balanceOf(address(this)) >= userReward);\n"],"loc":["./src/Contract.sol"]},{"content":["853:        require(usdcAddress.transfer(msg.sender, userReward));\n"],"loc":["./src/Contract.sol"]},{"content":["858:        require(userInfo.claimableRewards > 0);\n"],"loc":["./src/Contract.sol"]},{"content":["872:        require(usdcAddress.balanceOf(address(this)) >= userReward);\n"],"loc":["./src/Contract.sol"]},{"content":["873:        require(usdcAddress.transfer(adminWallet, userReward));\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Remove any unused functions","description":"Any functions not used should be removed as best practice.","gasSavings":null,"category":null,"instances":[{"content":["129:    function _msgSender() internal view virtual returns (address) {\n"],"loc":["./src/Contract.sol"]},{"content":["133:    function _msgData() internal view virtual returns (bytes calldata) {\n"],"loc":["./src/Contract.sol"]},{"content":["389:    function _mint(address account, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["415:    function _burn(address account, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["580:    function _reentrancyGuardEntered() internal view returns (bool) {\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"This variable's default value is the same as the value it is initialized with","description":"This is unnecessary and will have some overhead on Gas","gasSavings":null,"category":null,"instances":[{"content":["600:    uint256 public totalDeposited = 0;\n"],"loc":["./src/Contract.sol"]},{"content":["601:    uint256 public totalPending = 0;\n"],"loc":["./src/Contract.sol"]},{"content":["604:    uint256 public currentEpoch = 0;\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Function parameters should be in camelCase","description":"Ensure that function parameters are declared using camelCase","gasSavings":null,"category":null,"instances":[{"content":["33:    function balanceOf(address account) external view returns (uint256);\n"],"loc":["./src/Contract.sol"]},{"content":["42:    function transfer(address to, uint256 amount) external returns (bool);\n"],"loc":["./src/Contract.sol"]},{"content":["42:    function transfer(address to, uint256 amount) external returns (bool);\n"],"loc":["./src/Contract.sol"]},{"content":["51:    function allowance(address owner, address spender) external view returns (uint256);\n"],"loc":["./src/Contract.sol"]},{"content":["51:    function allowance(address owner, address spender) external view returns (uint256);\n"],"loc":["./src/Contract.sol"]},{"content":["67:    function approve(address spender, uint256 amount) external returns (bool);\n"],"loc":["./src/Contract.sol"]},{"content":["67:    function approve(address spender, uint256 amount) external returns (bool);\n"],"loc":["./src/Contract.sol"]},{"content":["78:    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n"],"loc":["./src/Contract.sol"]},{"content":["78:    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n"],"loc":["./src/Contract.sol"]},{"content":["78:    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n"],"loc":["./src/Contract.sol"]},{"content":["192:    constructor(string memory name_, string memory symbol_) {\n"],"loc":["./src/Contract.sol"]},{"content":["192:    constructor(string memory name_, string memory symbol_) {\n"],"loc":["./src/Contract.sol"]},{"content":["239:    function balanceOf(address account) public view virtual override returns (uint256) {\n"],"loc":["./src/Contract.sol"]},{"content":["251:    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["251:    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["260:    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n"],"loc":["./src/Contract.sol"]},{"content":["260:    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n"],"loc":["./src/Contract.sol"]},{"content":["274:    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["274:    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["296:    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["296:    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["296:    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["315:    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["335:    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["360:    function _transfer(address from, address to, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["360:    function _transfer(address from, address to, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["360:    function _transfer(address from, address to, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["389:    function _mint(address account, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["389:    function _mint(address account, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["415:    function _burn(address account, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["415:    function _burn(address account, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["446:    function _approve(address owner, address spender, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["446:    function _approve(address owner, address spender, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["446:    function _approve(address owner, address spender, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["462:    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["462:    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["462:    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n"],"loc":["./src/Contract.sol"]},{"content":["486:    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n"],"loc":["./src/Contract.sol"]},{"content":["486:    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n"],"loc":["./src/Contract.sol"]},{"content":["486:    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n"],"loc":["./src/Contract.sol"]},{"content":["502:    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n"],"loc":["./src/Contract.sol"]},{"content":["502:    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n"],"loc":["./src/Contract.sol"]},{"content":["502:    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n"],"loc":["./src/Contract.sol"]},{"content":["634:    constructor(address _owner, address _adminWallet) {\n"],"loc":["./src/Contract.sol"]},{"content":["675:    function getUserDeposit(address addr) external view returns (depositor memory) {\n"],"loc":["./src/Contract.sol"]},{"content":["687:    function deposit(uint256 amount) external nonReentrant{\n"],"loc":["./src/Contract.sol"]},{"content":["786:    function requestWithdraw(uint256 amount) external nonReentrant{\n"],"loc":["./src/Contract.sol"]},{"content":["829:    function distributeRewards(uint256 amount, uint256 adminBalance) external onlyOwner {\n"],"loc":["./src/Contract.sol"]}]},{"severity":"NonCritical","title":"Consider explicitly naming mapping parameters","description":"Consider explicitly naming mapping parameters for readability","gasSavings":null,"category":null,"instances":[{"content":["177:    mapping(address => uint256) private _balances;\n"],"loc":["./src/Contract.sol"]},{"content":["179:    mapping(address => mapping(address => uint256)) private _allowances;\n"],"loc":["./src/Contract.sol"]},{"content":["632:    mapping (address => depositor) userDepositInfo;\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Avoid Reading From Storage in a for loop","description":"\n  - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["711:        for (uint i = 0; i < awaitingApproval.length; i++) \n712:        {\n713:            depositor storage user = userDepositInfo[awaitingApproval[i]];\n714:            if(findAddressIndex(sucessfullyDeposited, awaitingApproval[i]) > sucessfullyDeposited.length){\n715:                sucessfullyDeposited.push(awaitingApproval[i]);\n716:            }\n717:\n718:            uint256 pendingAmount = user.pendingAmount;\n719:\n720:            user.amount += pendingAmount;\n721:            user.pendingAmount = 0;\n722:\n723:            totalDeposited += pendingAmount;\n724:\n725:        }\n"],"loc":["./src/Contract.sol"]},{"content":["711:        for (uint i = 0; i < awaitingApproval.length; i++) \n712:        {\n713:            depositor storage user = userDepositInfo[awaitingApproval[i]];\n714:            if(findAddressIndex(sucessfullyDeposited, awaitingApproval[i]) > sucessfullyDeposited.length){\n715:                sucessfullyDeposited.push(awaitingApproval[i]);\n716:            }\n717:\n718:            uint256 pendingAmount = user.pendingAmount;\n719:\n720:            user.amount += pendingAmount;\n721:            user.pendingAmount = 0;\n722:\n723:            totalDeposited += pendingAmount;\n724:\n725:        }\n"],"loc":["./src/Contract.sol"]},{"content":["739:        for (uint i = 0; i < withdrawRequests.length; i++) \n740:        {\n741:            depositor storage user = userDepositInfo[withdrawRequests[i]];\n742:            uint256 withdrawAmount = user.withrawalRequestAmount;\n743:\n744:            // take the amount from the pending first\n745:            if(user.pendingAmount > 0){\n746:                if(withdrawAmount > user.pendingAmount){\n747:                    withdrawAmount -= user.pendingAmount;\n748:                    totalPending -= user.pendingAmount;\n749:                    user.pendingAmount = 0;\n750:\n751:                    // user has no more pending amount, delete address from awaitingApproval array\n752:                    awaitingApproval = deleteAddressFromArray(awaitingApproval, withdrawRequests[i]);\n753:                }else{\n754:                    user.pendingAmount -= withdrawAmount;\n755:                    totalPending -= withdrawAmount;\n756:                    withdrawAmount = 0;\n757:                }\n758:            }\n759:\n760:            // take the rest from the deposited amount\n761:            if(withdrawAmount > 0){\n762:                user.amount -= withdrawAmount;\n763:\n764:                // total deposit decreases by the amount removed from amount, not from pending amount\n765:                totalDeposited -= withdrawAmount;\n766:            }\n767:\n768:            totalWithdrawAmount += user.withrawalRequestAmount;\n769:\n770:            user.withdrawApproved = true;\n771:            user.withdrawableAmount = user.withrawalRequestAmount;\n772:            user.withrawalRequestAmount = 0;\n773:\n774:            // user has no more deposit left, remove from sucessfullyDeposited array\n775:            if(user.amount == 0){\n776:                sucessfullyDeposited = deleteAddressFromArray(sucessfullyDeposited, withdrawRequests[i]);\n777:            }\n778:        }\n"],"loc":["./src/Contract.sol"]},{"content":["739:        for (uint i = 0; i < withdrawRequests.length; i++) \n740:        {\n741:            depositor storage user = userDepositInfo[withdrawRequests[i]];\n742:            uint256 withdrawAmount = user.withrawalRequestAmount;\n743:\n744:            // take the amount from the pending first\n745:            if(user.pendingAmount > 0){\n746:                if(withdrawAmount > user.pendingAmount){\n747:                    withdrawAmount -= user.pendingAmount;\n748:                    totalPending -= user.pendingAmount;\n749:                    user.pendingAmount = 0;\n750:\n751:                    // user has no more pending amount, delete address from awaitingApproval array\n752:                    awaitingApproval = deleteAddressFromArray(awaitingApproval, withdrawRequests[i]);\n753:                }else{\n754:                    user.pendingAmount -= withdrawAmount;\n755:                    totalPending -= withdrawAmount;\n756:                    withdrawAmount = 0;\n757:                }\n758:            }\n759:\n760:            // take the rest from the deposited amount\n761:            if(withdrawAmount > 0){\n762:                user.amount -= withdrawAmount;\n763:\n764:                // total deposit decreases by the amount removed from amount, not from pending amount\n765:                totalDeposited -= withdrawAmount;\n766:            }\n767:\n768:            totalWithdrawAmount += user.withrawalRequestAmount;\n769:\n770:            user.withdrawApproved = true;\n771:            user.withdrawableAmount = user.withrawalRequestAmount;\n772:            user.withrawalRequestAmount = 0;\n773:\n774:            // user has no more deposit left, remove from sucessfullyDeposited array\n775:            if(user.amount == 0){\n776:                sucessfullyDeposited = deleteAddressFromArray(sucessfullyDeposited, withdrawRequests[i]);\n777:            }\n778:        }\n"],"loc":["./src/Contract.sol"]},{"content":["739:        for (uint i = 0; i < withdrawRequests.length; i++) \n740:        {\n741:            depositor storage user = userDepositInfo[withdrawRequests[i]];\n742:            uint256 withdrawAmount = user.withrawalRequestAmount;\n743:\n744:            // take the amount from the pending first\n745:            if(user.pendingAmount > 0){\n746:                if(withdrawAmount > user.pendingAmount){\n747:                    withdrawAmount -= user.pendingAmount;\n748:                    totalPending -= user.pendingAmount;\n749:                    user.pendingAmount = 0;\n750:\n751:                    // user has no more pending amount, delete address from awaitingApproval array\n752:                    awaitingApproval = deleteAddressFromArray(awaitingApproval, withdrawRequests[i]);\n753:                }else{\n754:                    user.pendingAmount -= withdrawAmount;\n755:                    totalPending -= withdrawAmount;\n756:                    withdrawAmount = 0;\n757:                }\n758:            }\n759:\n760:            // take the rest from the deposited amount\n761:            if(withdrawAmount > 0){\n762:                user.amount -= withdrawAmount;\n763:\n764:                // total deposit decreases by the amount removed from amount, not from pending amount\n765:                totalDeposited -= withdrawAmount;\n766:            }\n767:\n768:            totalWithdrawAmount += user.withrawalRequestAmount;\n769:\n770:            user.withdrawApproved = true;\n771:            user.withdrawableAmount = user.withrawalRequestAmount;\n772:            user.withrawalRequestAmount = 0;\n773:\n774:            // user has no more deposit left, remove from sucessfullyDeposited array\n775:            if(user.amount == 0){\n776:                sucessfullyDeposited = deleteAddressFromArray(sucessfullyDeposited, withdrawRequests[i]);\n777:            }\n778:        }\n"],"loc":["./src/Contract.sol"]},{"content":["739:        for (uint i = 0; i < withdrawRequests.length; i++) \n740:        {\n741:            depositor storage user = userDepositInfo[withdrawRequests[i]];\n742:            uint256 withdrawAmount = user.withrawalRequestAmount;\n743:\n744:            // take the amount from the pending first\n745:            if(user.pendingAmount > 0){\n746:                if(withdrawAmount > user.pendingAmount){\n747:                    withdrawAmount -= user.pendingAmount;\n748:                    totalPending -= user.pendingAmount;\n749:                    user.pendingAmount = 0;\n750:\n751:                    // user has no more pending amount, delete address from awaitingApproval array\n752:                    awaitingApproval = deleteAddressFromArray(awaitingApproval, withdrawRequests[i]);\n753:                }else{\n754:                    user.pendingAmount -= withdrawAmount;\n755:                    totalPending -= withdrawAmount;\n756:                    withdrawAmount = 0;\n757:                }\n758:            }\n759:\n760:            // take the rest from the deposited amount\n761:            if(withdrawAmount > 0){\n762:                user.amount -= withdrawAmount;\n763:\n764:                // total deposit decreases by the amount removed from amount, not from pending amount\n765:                totalDeposited -= withdrawAmount;\n766:            }\n767:\n768:            totalWithdrawAmount += user.withrawalRequestAmount;\n769:\n770:            user.withdrawApproved = true;\n771:            user.withdrawableAmount = user.withrawalRequestAmount;\n772:            user.withrawalRequestAmount = 0;\n773:\n774:            // user has no more deposit left, remove from sucessfullyDeposited array\n775:            if(user.amount == 0){\n776:                sucessfullyDeposited = deleteAddressFromArray(sucessfullyDeposited, withdrawRequests[i]);\n777:            }\n778:        }\n"],"loc":["./src/Contract.sol"]},{"content":["739:        for (uint i = 0; i < withdrawRequests.length; i++) \n740:        {\n741:            depositor storage user = userDepositInfo[withdrawRequests[i]];\n742:            uint256 withdrawAmount = user.withrawalRequestAmount;\n743:\n744:            // take the amount from the pending first\n745:            if(user.pendingAmount > 0){\n746:                if(withdrawAmount > user.pendingAmount){\n747:                    withdrawAmount -= user.pendingAmount;\n748:                    totalPending -= user.pendingAmount;\n749:                    user.pendingAmount = 0;\n750:\n751:                    // user has no more pending amount, delete address from awaitingApproval array\n752:                    awaitingApproval = deleteAddressFromArray(awaitingApproval, withdrawRequests[i]);\n753:                }else{\n754:                    user.pendingAmount -= withdrawAmount;\n755:                    totalPending -= withdrawAmount;\n756:                    withdrawAmount = 0;\n757:                }\n758:            }\n759:\n760:            // take the rest from the deposited amount\n761:            if(withdrawAmount > 0){\n762:                user.amount -= withdrawAmount;\n763:\n764:                // total deposit decreases by the amount removed from amount, not from pending amount\n765:                totalDeposited -= withdrawAmount;\n766:            }\n767:\n768:            totalWithdrawAmount += user.withrawalRequestAmount;\n769:\n770:            user.withdrawApproved = true;\n771:            user.withdrawableAmount = user.withrawalRequestAmount;\n772:            user.withrawalRequestAmount = 0;\n773:\n774:            // user has no more deposit left, remove from sucessfullyDeposited array\n775:            if(user.amount == 0){\n776:                sucessfullyDeposited = deleteAddressFromArray(sucessfullyDeposited, withdrawRequests[i]);\n777:            }\n778:        }\n"],"loc":["./src/Contract.sol"]},{"content":["739:        for (uint i = 0; i < withdrawRequests.length; i++) \n740:        {\n741:            depositor storage user = userDepositInfo[withdrawRequests[i]];\n742:            uint256 withdrawAmount = user.withrawalRequestAmount;\n743:\n744:            // take the amount from the pending first\n745:            if(user.pendingAmount > 0){\n746:                if(withdrawAmount > user.pendingAmount){\n747:                    withdrawAmount -= user.pendingAmount;\n748:                    totalPending -= user.pendingAmount;\n749:                    user.pendingAmount = 0;\n750:\n751:                    // user has no more pending amount, delete address from awaitingApproval array\n752:                    awaitingApproval = deleteAddressFromArray(awaitingApproval, withdrawRequests[i]);\n753:                }else{\n754:                    user.pendingAmount -= withdrawAmount;\n755:                    totalPending -= withdrawAmount;\n756:                    withdrawAmount = 0;\n757:                }\n758:            }\n759:\n760:            // take the rest from the deposited amount\n761:            if(withdrawAmount > 0){\n762:                user.amount -= withdrawAmount;\n763:\n764:                // total deposit decreases by the amount removed from amount, not from pending amount\n765:                totalDeposited -= withdrawAmount;\n766:            }\n767:\n768:            totalWithdrawAmount += user.withrawalRequestAmount;\n769:\n770:            user.withdrawApproved = true;\n771:            user.withdrawableAmount = user.withrawalRequestAmount;\n772:            user.withrawalRequestAmount = 0;\n773:\n774:            // user has no more deposit left, remove from sucessfullyDeposited array\n775:            if(user.amount == 0){\n776:                sucessfullyDeposited = deleteAddressFromArray(sucessfullyDeposited, withdrawRequests[i]);\n777:            }\n778:        }\n"],"loc":["./src/Contract.sol"]},{"content":["831:        for (uint i = 0; i < sucessfullyDeposited.length; i++) \n832:        {\n833:            depositor storage userInfo = userDepositInfo[sucessfullyDeposited[i]];\n834:            uint256 userReward = userInfo.amount * amount / totalDeposited;\n835:\n836:            userInfo.claimableRewards += userReward;\n837:        }\n"],"loc":["./src/Contract.sol"]},{"content":["831:        for (uint i = 0; i < sucessfullyDeposited.length; i++) \n832:        {\n833:            depositor storage userInfo = userDepositInfo[sucessfullyDeposited[i]];\n834:            uint256 userReward = userInfo.amount * amount / totalDeposited;\n835:\n836:            userInfo.claimableRewards += userReward;\n837:        }\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Mark storage variables as `constant` if they never change.","description":"\n State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. \n The compiler does not reserve a storage slot for these variables, and every occurrence is inlined by the respective value. \n Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values. - Savings: ~2103 \n","gasSavings":null,"category":null,"instances":[{"content":["595:    uint256 decimals = 6;\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Mark storage variables as `immutable` if they never change after contract initialization.","description":"\n State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. \n The compiler does not reserve a storage slot for these variables, and every occurrence is inlined by the respective value. \n Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values. \n - Savings: ~2103 \n","gasSavings":null,"category":null,"instances":[{"content":["597:    address public owner;\n"],"loc":["./src/Contract.sol"]},{"content":["183:    string private _name;\n"],"loc":["./src/Contract.sol"]},{"content":["184:    string private _symbol;\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"`unchecked{++i}` instead of `i++` (or use assembly when applicable)","description":"\n Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas. - Savings: ~342 \n","gasSavings":null,"category":null,"instances":[{"content":["894:        for (uint i = indexToDelete; i < newArray.length; i++) {\n"],"loc":["./src/Contract.sol"]},{"content":["711:        for (uint i = 0; i < awaitingApproval.length; i++) \n"],"loc":["./src/Contract.sol"]},{"content":["891:        for (uint i = 0; i < indexToDelete; i++) {\n"],"loc":["./src/Contract.sol"]},{"content":["831:        for (uint i = 0; i < sucessfullyDeposited.length; i++) \n"],"loc":["./src/Contract.sol"]},{"content":["877:        for (uint i = 0; i < addressArray.length; i++) {\n"],"loc":["./src/Contract.sol"]},{"content":["739:        for (uint i = 0; i < withdrawRequests.length; i++) \n"],"loc":["./src/Contract.sol"]},{"content":["666:        for (uint i = 0; i < withdrawRequests.length; i++) \n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Cache Storage Variables in Memory","description":"\n  - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["369:            _balances[from] = fromBalance - amount;\n"],"loc":["./src/Contract.sol"]},{"content":["372:            _balances[to] += amount;\n"],"loc":["./src/Contract.sol"]},{"content":["369:            _balances[from] = fromBalance - amount;\n"],"loc":["./src/Contract.sol"]},{"content":["372:            _balances[to] += amount;\n"],"loc":["./src/Contract.sol"]},{"content":["423:            _balances[account] = accountBalance - amount;\n"],"loc":["./src/Contract.sol"]},{"content":["423:            _balances[account] = accountBalance - amount;\n"],"loc":["./src/Contract.sol"]},{"content":["567:        _status = _ENTERED;\n"],"loc":["./src/Contract.sol"]},{"content":["668:            depositor memory user = userDepositInfo[withdrawRequests[i]];\n"],"loc":["./src/Contract.sol"]},{"content":["684:        require(usdcAddress.transfer(adminWallet, usdcAddress.balanceOf(address(this))));\n"],"loc":["./src/Contract.sol"]},{"content":["684:        require(usdcAddress.transfer(adminWallet, usdcAddress.balanceOf(address(this))));\n"],"loc":["./src/Contract.sol"]},{"content":["702:        if(findAddressIndex(awaitingApproval, msg.sender) > awaitingApproval.length){\n"],"loc":["./src/Contract.sol"]},{"content":["703:            awaitingApproval.push(msg.sender);\n"],"loc":["./src/Contract.sol"]},{"content":["707:        require(usdcAddress.transferFrom(msg.sender, adminWallet, amount));\n"],"loc":["./src/Contract.sol"]},{"content":["702:        if(findAddressIndex(awaitingApproval, msg.sender) > awaitingApproval.length){\n"],"loc":["./src/Contract.sol"]},{"content":["703:            awaitingApproval.push(msg.sender);\n"],"loc":["./src/Contract.sol"]},{"content":["707:        require(usdcAddress.transferFrom(msg.sender, adminWallet, amount));\n"],"loc":["./src/Contract.sol"]},{"content":["714:            if(findAddressIndex(sucessfullyDeposited, awaitingApproval[i]) > sucessfullyDeposited.length){\n"],"loc":["./src/Contract.sol"]},{"content":["714:            if(findAddressIndex(sucessfullyDeposited, awaitingApproval[i]) > sucessfullyDeposited.length){\n"],"loc":["./src/Contract.sol"]},{"content":["715:                sucessfullyDeposited.push(awaitingApproval[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["715:                sucessfullyDeposited.push(awaitingApproval[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["732:        delete awaitingApproval;\n"],"loc":["./src/Contract.sol"]},{"content":["714:            if(findAddressIndex(sucessfullyDeposited, awaitingApproval[i]) > sucessfullyDeposited.length){\n"],"loc":["./src/Contract.sol"]},{"content":["714:            if(findAddressIndex(sucessfullyDeposited, awaitingApproval[i]) > sucessfullyDeposited.length){\n"],"loc":["./src/Contract.sol"]},{"content":["715:                sucessfullyDeposited.push(awaitingApproval[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["715:                sucessfullyDeposited.push(awaitingApproval[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["732:        delete awaitingApproval;\n"],"loc":["./src/Contract.sol"]},{"content":["752:                    awaitingApproval = deleteAddressFromArray(awaitingApproval, withdrawRequests[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["752:                    awaitingApproval = deleteAddressFromArray(awaitingApproval, withdrawRequests[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["755:                    totalPending -= withdrawAmount;\n"],"loc":["./src/Contract.sol"]},{"content":["776:                sucessfullyDeposited = deleteAddressFromArray(sucessfullyDeposited, withdrawRequests[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["776:                sucessfullyDeposited = deleteAddressFromArray(sucessfullyDeposited, withdrawRequests[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["780:        delete withdrawRequests;\n"],"loc":["./src/Contract.sol"]},{"content":["752:                    awaitingApproval = deleteAddressFromArray(awaitingApproval, withdrawRequests[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["752:                    awaitingApproval = deleteAddressFromArray(awaitingApproval, withdrawRequests[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["755:                    totalPending -= withdrawAmount;\n"],"loc":["./src/Contract.sol"]},{"content":["776:                sucessfullyDeposited = deleteAddressFromArray(sucessfullyDeposited, withdrawRequests[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["776:                sucessfullyDeposited = deleteAddressFromArray(sucessfullyDeposited, withdrawRequests[i]);\n"],"loc":["./src/Contract.sol"]},{"content":["780:        delete withdrawRequests;\n"],"loc":["./src/Contract.sol"]},{"content":["798:        if(findAddressIndex(withdrawRequests, msg.sender) > withdrawRequests.length){\n"],"loc":["./src/Contract.sol"]},{"content":["799:            withdrawRequests.push(msg.sender);\n"],"loc":["./src/Contract.sol"]},{"content":["798:        if(findAddressIndex(withdrawRequests, msg.sender) > withdrawRequests.length){\n"],"loc":["./src/Contract.sol"]},{"content":["799:            withdrawRequests.push(msg.sender);\n"],"loc":["./src/Contract.sol"]},{"content":["806:        require(findAddressIndex(withdrawRequests, msg.sender) <= withdrawRequests.length);\n"],"loc":["./src/Contract.sol"]},{"content":["812:        withdrawRequests = deleteAddressFromArray(withdrawRequests, msg.sender);\n"],"loc":["./src/Contract.sol"]},{"content":["812:        withdrawRequests = deleteAddressFromArray(withdrawRequests, msg.sender);\n"],"loc":["./src/Contract.sol"]},{"content":["806:        require(findAddressIndex(withdrawRequests, msg.sender) <= withdrawRequests.length);\n"],"loc":["./src/Contract.sol"]},{"content":["812:        withdrawRequests = deleteAddressFromArray(withdrawRequests, msg.sender);\n"],"loc":["./src/Contract.sol"]},{"content":["812:        withdrawRequests = deleteAddressFromArray(withdrawRequests, msg.sender);\n"],"loc":["./src/Contract.sol"]},{"content":["826:        require(usdcAddress.transfer(msg.sender, amountToSend));\n"],"loc":["./src/Contract.sol"]},{"content":["826:        require(usdcAddress.transfer(msg.sender, amountToSend));\n"],"loc":["./src/Contract.sol"]},{"content":["833:            depositor storage userInfo = userDepositInfo[sucessfullyDeposited[i]];\n"],"loc":["./src/Contract.sol"]},{"content":["839:        history.push(rewardHistory(totalDeposited, amount, block.timestamp - lastEpochTime, adminBalance));\n"],"loc":["./src/Contract.sol"]},{"content":["833:            depositor storage userInfo = userDepositInfo[sucessfullyDeposited[i]];\n"],"loc":["./src/Contract.sol"]},{"content":["839:        history.push(rewardHistory(totalDeposited, amount, block.timestamp - lastEpochTime, adminBalance));\n"],"loc":["./src/Contract.sol"]},{"content":["853:        require(usdcAddress.transfer(msg.sender, userReward));\n"],"loc":["./src/Contract.sol"]},{"content":["853:        require(usdcAddress.transfer(msg.sender, userReward));\n"],"loc":["./src/Contract.sol"]},{"content":["868:        if(findAddressIndex(awaitingApproval, msg.sender) > awaitingApproval.length){\n"],"loc":["./src/Contract.sol"]},{"content":["869:            awaitingApproval.push(msg.sender);\n"],"loc":["./src/Contract.sol"]},{"content":["873:        require(usdcAddress.transfer(adminWallet, userReward));\n"],"loc":["./src/Contract.sol"]},{"content":["868:        if(findAddressIndex(awaitingApproval, msg.sender) > awaitingApproval.length){\n"],"loc":["./src/Contract.sol"]},{"content":["869:            awaitingApproval.push(msg.sender);\n"],"loc":["./src/Contract.sol"]},{"content":["873:        require(usdcAddress.transfer(adminWallet, userReward));\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Use assembly to check for address(0)","description":"\n  - Savings: ~6 \n","gasSavings":null,"category":null,"instances":[{"content":["361:        require(from != address(0), \"ERC20: transfer from the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["362:        require(to != address(0), \"ERC20: transfer to the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["390:        require(account != address(0), \"ERC20: mint to the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["416:        require(account != address(0), \"ERC20: burn from the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["447:        require(owner != address(0), \"ERC20: approve from the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["448:        require(spender != address(0), \"ERC20: approve to the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["635:        require(_owner != address(0), \"Owner address cannot be zero\");\n"],"loc":["./src/Contract.sol"]},{"content":["636:        require(_adminWallet != address(0), \"Admin wallet cannot be zero\");\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Optimal Comparison","description":"\n When comparing integers, it is cheaper to use strict `>` & `<` operators over `>=` & `<=` operators, even if you must increment or decrement one of the operands. \n Note: before using this technique, it's important to consider whether incrementing/decrementing one of the operators could result in an over/underflow. This optimization is applicable when the optimizer is turned off. - Savings: ~3 \n","gasSavings":null,"category":null,"instances":[{"content":["338:        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n"],"loc":["./src/Contract.sol"]},{"content":["367:        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n"],"loc":["./src/Contract.sol"]},{"content":["421:        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n"],"loc":["./src/Contract.sol"]},{"content":["465:            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n"],"loc":["./src/Contract.sol"]},{"content":["706:        require(usdcAddress.balanceOf(msg.sender) >= amount);\n"],"loc":["./src/Contract.sol"]},{"content":["793:        require(userInfo.amount + userInfo.pendingAmount >= userInfo.withrawalRequestAmount + amount);\n"],"loc":["./src/Contract.sol"]},{"content":["806:        require(findAddressIndex(withdrawRequests, msg.sender) <= withdrawRequests.length);\n"],"loc":["./src/Contract.sol"]},{"content":["825:        require(usdcAddress.balanceOf(address(this)) >= amountToSend);\n"],"loc":["./src/Contract.sol"]},{"content":["852:        require(usdcAddress.balanceOf(address(this)) >= userReward);\n"],"loc":["./src/Contract.sol"]},{"content":["872:        require(usdcAddress.balanceOf(address(this)) >= userReward);\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Use `calldata` instead of `memory` for function arguments that do not get mutated.","description":"\n Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage. - Savings: ~1716 \n","gasSavings":null,"category":null,"instances":[{"content":["876:    function findAddressIndex(address[] memory addressArray, address addressToFind) internal pure returns (uint) {\n"],"loc":["./src/Contract.sol"]},{"content":["885:    function deleteAddressFromArray(address[] memory addressArray, address addressToDelete) internal pure returns (address[] memory) {\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Use assembly for math (add, sub, mul, div)","description":"\n Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow. - Savings: ~60 \n","gasSavings":null,"category":null,"instances":[{"content":["317:        _approve(owner, spender, allowance(owner, spender) + addedValue);\n"],"loc":["./src/Contract.sol"]},{"content":["340:            _approve(owner, spender, currentAllowance - subtractedValue);\n"],"loc":["./src/Contract.sol"]},{"content":["369:            _balances[from] = fromBalance - amount;\n"],"loc":["./src/Contract.sol"]},{"content":["423:            _balances[account] = accountBalance - amount;\n"],"loc":["./src/Contract.sol"]},{"content":["467:                _approve(owner, spender, currentAllowance - amount);\n"],"loc":["./src/Contract.sol"]},{"content":["793:        require(userInfo.amount + userInfo.pendingAmount >= userInfo.withrawalRequestAmount + amount);\n"],"loc":["./src/Contract.sol"]},{"content":["793:        require(userInfo.amount + userInfo.pendingAmount >= userInfo.withrawalRequestAmount + amount);\n"],"loc":["./src/Contract.sol"]},{"content":["834:            uint256 userReward = userInfo.amount * amount / totalDeposited;\n"],"loc":["./src/Contract.sol"]},{"content":["834:            uint256 userReward = userInfo.amount * amount / totalDeposited;\n"],"loc":["./src/Contract.sol"]},{"content":["839:        history.push(rewardHistory(totalDeposited, amount, block.timestamp - lastEpochTime, adminBalance));\n"],"loc":["./src/Contract.sol"]},{"content":["886:        address[] memory newArray = new address[](addressArray.length - 1);\n"],"loc":["./src/Contract.sol"]},{"content":["895:            newArray[i] = addressArray[i + 1];\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Use assembly to write storage values","description":"\n You can save a fair amount of gas by using assembly to write storage values. - Savings: ~66 \n","gasSavings":null,"category":null,"instances":[{"content":["193:        _name = name_;\n"],"loc":["./src/Contract.sol"]},{"content":["194:        _symbol = symbol_;\n"],"loc":["./src/Contract.sol"]},{"content":["546:        _status = _NOT_ENTERED;\n"],"loc":["./src/Contract.sol"]},{"content":["567:        _status = _ENTERED;\n"],"loc":["./src/Contract.sol"]},{"content":["573:        _status = _NOT_ENTERED;\n"],"loc":["./src/Contract.sol"]},{"content":["638:        lastEpochTime = block.timestamp;\n"],"loc":["./src/Contract.sol"]},{"content":["639:        owner = _owner;\n"],"loc":["./src/Contract.sol"]},{"content":["640:        adminWallet = _adminWallet;\n"],"loc":["./src/Contract.sol"]},{"content":["680:        adminWallet = newWallet;\n"],"loc":["./src/Contract.sol"]},{"content":["728:        totalPending = 0;\n"],"loc":["./src/Contract.sol"]},{"content":["729:        lastEpochTime = block.timestamp;\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Event is not properly indexed.","description":"\n When possible, always include a minimum of 3 indexed event topics to save gas - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["17:    event Transfer(address indexed from, address indexed to, uint256 value);\n"],"loc":["./src/Contract.sol"]},{"content":["23:    event Approval(address indexed owner, address indexed spender, uint256 value);\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Mark functions as payable (with discretion)","description":"\n You can mark public or external functions as payable to save gas. Functions that are not payable have additional logic to check if there was a value sent with a call, however, making a function payable eliminates this check. This optimization should be carefully considered due to potentially unwanted behavior when a function does not need to accept ether. - Savings: ~24 \n","gasSavings":null,"category":null,"instances":[{"content":["200:    function name() public view virtual override returns (string memory) {\n"],"loc":["./src/Contract.sol"]},{"content":["208:    function symbol() public view virtual override returns (string memory) {\n"],"loc":["./src/Contract.sol"]},{"content":["225:    function decimals() public view virtual override returns (uint8) {\n"],"loc":["./src/Contract.sol"]},{"content":["232:    function totalSupply() public view virtual override returns (uint256) {\n"],"loc":["./src/Contract.sol"]},{"content":["239:    function balanceOf(address account) public view virtual override returns (uint256) {\n"],"loc":["./src/Contract.sol"]},{"content":["251:    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["260:    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n"],"loc":["./src/Contract.sol"]},{"content":["274:    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["296:    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["315:    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["335:    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n"],"loc":["./src/Contract.sol"]},{"content":["648:    function getAwaitingApproval() external view returns (address[] memory){\n"],"loc":["./src/Contract.sol"]},{"content":["652:    function getWithdrawRequests() external view returns (address[] memory){\n"],"loc":["./src/Contract.sol"]},{"content":["656:    function getSuccessfullyDeposited() external view returns (address[] memory){\n"],"loc":["./src/Contract.sol"]},{"content":["660:    function getHistory() external view returns (rewardHistory[] memory){\n"],"loc":["./src/Contract.sol"]},{"content":["664:    function getWithdrawRequestsAmount() external view returns(uint256) {\n"],"loc":["./src/Contract.sol"]},{"content":["675:    function getUserDeposit(address addr) external view returns (depositor memory) {\n"],"loc":["./src/Contract.sol"]},{"content":["679:    function changeAdminWallet(address newWallet) external onlyOwner {\n"],"loc":["./src/Contract.sol"]},{"content":["683:    function removeTokens() external onlyOwner {\n"],"loc":["./src/Contract.sol"]},{"content":["687:    function deposit(uint256 amount) external nonReentrant{\n"],"loc":["./src/Contract.sol"]},{"content":["710:    function startNewCycle() external onlyOwner {\n"],"loc":["./src/Contract.sol"]},{"content":["735:    function approveWithdrawRequests() external onlyOwner {\n"],"loc":["./src/Contract.sol"]},{"content":["786:    function requestWithdraw(uint256 amount) external nonReentrant{\n"],"loc":["./src/Contract.sol"]},{"content":["803:    function cancelRequestWithdraw() external nonReentrant{\n"],"loc":["./src/Contract.sol"]},{"content":["815:    function withdraw() external nonReentrant{\n"],"loc":["./src/Contract.sol"]},{"content":["829:    function distributeRewards(uint256 amount, uint256 adminBalance) external onlyOwner {\n"],"loc":["./src/Contract.sol"]},{"content":["844:    function claimRewards() external nonReentrant{\n"],"loc":["./src/Contract.sol"]},{"content":["856:    function reDeposit() external nonReentrant{\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Cache array length during for loop definition.","description":"\n A typical for loop definition may look like: `for (uint256 i; i < arr.length; i++){}`. Instead of using `array.length`, cache the array length before the loop, and use the cached value to safe gas. This will avoid an `MLOAD` every loop for arrays stored in memory and an `SLOAD` for arrays stored in storage. This can have significant gas savings for arrays with a large length, especially if the array is stored in storage. - Savings: ~22 \n","gasSavings":null,"category":null,"instances":[{"content":["666:        for (uint i = 0; i < withdrawRequests.length; i++) \n"],"loc":["./src/Contract.sol"]},{"content":["711:        for (uint i = 0; i < awaitingApproval.length; i++) \n"],"loc":["./src/Contract.sol"]},{"content":["739:        for (uint i = 0; i < withdrawRequests.length; i++) \n"],"loc":["./src/Contract.sol"]},{"content":["831:        for (uint i = 0; i < sucessfullyDeposited.length; i++) \n"],"loc":["./src/Contract.sol"]},{"content":["877:        for (uint i = 0; i < addressArray.length; i++) {\n"],"loc":["./src/Contract.sol"]},{"content":["894:        for (uint i = indexToDelete; i < newArray.length; i++) {\n"],"loc":["./src/Contract.sol"]}]},{"severity":"Gas","title":"Short Revert Strings","description":"\n Keeping revert strings under 32-bytes prevents the string from being stored in more than one memory slot. - Savings: ~3 \n","gasSavings":null,"category":null,"instances":[{"content":["338:        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n"],"loc":["./src/Contract.sol"]},{"content":["361:        require(from != address(0), \"ERC20: transfer from the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["362:        require(to != address(0), \"ERC20: transfer to the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["367:        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n"],"loc":["./src/Contract.sol"]},{"content":["416:        require(account != address(0), \"ERC20: burn from the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["421:        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n"],"loc":["./src/Contract.sol"]},{"content":["447:        require(owner != address(0), \"ERC20: approve from the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["448:        require(spender != address(0), \"ERC20: approve to the zero address\");\n"],"loc":["./src/Contract.sol"]},{"content":["783:        require(sent, \"Failed to transfer withdraw amount\");\n"],"loc":["./src/Contract.sol"]},{"content":["841:        require(sent, \"Failed to transfer funds from admin wallet\");\n"],"loc":["./src/Contract.sol"]}]}]}